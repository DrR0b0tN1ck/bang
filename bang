#!/usr/bin/env python

import argparse
import re
import yaml
import sys
import pprint

def scan_matching(in_text, start):
  # Scan through in_text, starting from the given start index (which should be
  # the index of an opening delimited), until the matching closing delimiter.
  # Return the index of the closing delimiter.
  verbose = False

  stack = list(in_text[start])
  i = start + 1

  while stack:
    if i >= len(in_text):
      raise Exception('Missing closing delimiter.  These remain open: %s' % ' '.join(stack))
    c = in_text[i]
    if verbose: print "Checking character", c, "Stack:", stack
    if c == ']':
      m = stack.pop()
      if m != '[': raise Exception('Mismatched delimiters. %c %c' % (m, c))
      if verbose: print "[ matched with ]"
    if c == '}':
      m = stack.pop()
      if m != '{': raise Exception('Mismatched delimiters. %c %c' % (m, c))
      if verbose: print "{ matched with }"
    if c in '[{':
      stack.append(c)
    if c in '\\':
      i+= 1
    i+= 1 
  return i

def find_template(in_text, start):
  # Look for a template in the given text, starting at the given position.
  # Return the starting and ending indices of the template we find, along with
  # the name, arguments, and body.
  verbose = False

  # Is there any text left to search?
  if start >= len(in_text):
    return None

  # Where does the next template in the string start?
  i = start
  while in_text[i] != '!':
    i+=1
    if i >= len(in_text): return None

  if verbose: print "Template starts at position %d." % i
  bang_index = i
  i+=1 # Move past the !.
  name_start = i

  # Where does the name of the first template end?
  while in_text[i].isalnum() or in_text[i] in '+':
    i+=1
  name_end = i
  name = in_text[name_start:name_end]
  if verbose: print "Name: %s" % name

  # If there are arguments, grab them.
  if in_text[i] == '[':
    arguments_start = i+1
    arguments_end = scan_matching(in_text, i) - 1
    arguments = in_text[arguments_start:arguments_end]
    i = arguments_end + 1
    if verbose: print "Arguments:", arguments
  else:
    if verbose: print "No arguments."
    arguments = None

  # If there is a body, grab it.
  if in_text[i] == '{':
    body_start = i+1
    body_end = scan_matching(in_text, i) - 1
    body = in_text[body_start:body_end]
    i = body_end + 1
    if verbose: print "Body:", body
  else:
    if verbose: print "No body."
    body = None
  
  return (bang_index, i, name, arguments, body)

def expand_template(config, name, arguments, body):
  # The name we get might actually be a series of template names, separated by
  # plus signs.  Separate them.
  names = name.split('+')

  # Get the config for each of these names. 
  specs = list()
  for name in names:
    try:
      specs.append(config['templates'][name])
    except KeyError:
      raise Exception('Template %s is not defined.' % name)

  # If there are multiple templates, then they should all refer to one single
  # base template.  If there's just one, it could be a base template or an
  # inherited one.  Let's figure out which we have.
  if len(specs) == 0:
    raise Exception("Template instance seems to be missing a name.")
  elif len(specs) > 1:
    blend = True
  elif 'inherit_from' in specs[0]:
    blend = True
  else:
    blend = False
  
  # Find the template that we'll actually use for the expansion.
  if blend:
    # Blended -- Make sure everyone inherits from the same place, and inherit
    # from there.
    base_name = None
    for spec in specs:
      this_base_name = spec['inherit_from']
      if base_name is None:
        base_name = this_base_name
      elif base_name != this_base_name:
        raise Exception("Cannot blend templates %s, because they inherit from different bases %s and %s" % (name, base_name, this_base_name))
    base_spec = config['templates'][base_name]
  else:
    # Not blended -- Just use that template.
    base_name = name
    base_spec = config['templates'][name]

  # Now let's build a dictionary of values to insert into the macro text,
  # starting with the instance body.
  values = dict()
  values['body'] = body

  # If it's a blended template, add the values given in those inherited templates.
  if blend:
    for spec in specs:
      for arg in [base_spec['default_arg'], ] + base_spec['special_args'].values():
        if arg in spec:
          val = spec[arg]
          if arg in values:
            values[arg] += val
          else:
            values[arg] = val
          

  # Add in anything specified in the arguments to this instace.
  if arguments is not None:
    default_arg = arguments # TODO: Split this up using the sigils, etc.
    try:
      values[base_spec['default_arg']] = default_arg
    except KeyError:
      raise Exception('Template %s instantiated with default argument (%s), but the template spec has no default argument.' % (name, default_arg))


  # Construct the final string by replacing $arg and ?arg markers in the text
  # with the appropriate values.
  try:
    text = base_spec['text']
  except KeyError:
    raise Exception('Template %s has no text field.' % base_name)

  def sub_arg_required(match):
    val_name = match.group(1)
    try:
      value = values[val_name]
      return value
    except KeyError:
      raise Exception("Template %s needs a %s, which is missing." % (name, val_name))
  text = re.sub(r'\$([A-Za-z]*)', sub_arg_required, text)

  def sub_arg_optional(match):
    val_name = match.group(1)
    try:
      value = values[val_name]
      return value
    except KeyError:
      return ""
  text = re.sub(r'\?([A-Za-z]*)', sub_arg_optional, text)

  return text


def bang(config, text):
  # Find a template in the given string.  Replace it with its appropriate
  # expansion.
  
  while True:
    ft_result = find_template(text, 0)
    if ft_result is None: break
    (template_start, template_end, name, arguments, body) = ft_result
    expansion = expand_template(config, name, arguments, body)
    text = text[:template_start] + expansion + text[template_end:]

  return text


## def bang(config, in_text):
##   verbose = True
## 
##   out_text = ""
## 
##   # For keeping track of what we expect to see next.
##   class State:
##     Top = "top level"
##     Name = "template name"
##     Args = "template args"
## 
##   state = State.Top
## 
##   while in_text:
##     c = in_text[0]
##     if verbose: print "Matching character (%c) in state %s." % (c, state)
## 
##     # An ordindary character?
##     if state == State.Top and c.isalnum():
##       if verbose: print "-- Ordinary top-level text."
##       out_text += c
##       in_text = in_text[1:]
##       continue
## 
##     # Start of a template?
##     if state == State.Top and c == '!':
##       if verbose: print "-- Start of template name."
##       state = State.Name
##       template_name = ""
##       in_text = in_text[1:]
##       continue
## 
##     # A character of a template name?
##     if state == State.Name and c.isalnum():
##       if verbose: print "-- Character in a template name."
##       template_name
##       in_text = in_text[1:]
##       continue
##       
##       
## 
##     # Nothing else matched.  This must be an ordinary character.
##     # if verbose: print "-- Ordinary character."
##     # out_text += c
##     # in_text = in_text[1:]
##     raise Exception("Did not expect character %c in state %s" % (c, state))
##    
##   return out_text


def check_config(config):
  # Perform some sanity checks on a given configuration.
  for template_name in config['templates']:
    template = config['templates'][template_name]
    has_text = 'text' in template
    has_inherit_from = 'inherit_from' in template
    if has_text and has_inherit_from:
      raise Exception("Template %s has both text and inherit_from fields." % template_name)
    if not has_text and not has_inherit_from:
      raise Exception("Template %s has neither text nor inherit_from fields." % template_name)




def main(args):
  # Make sure we have reasonable filenames.
  if not args.output_filename:
    args.output_filename = re.sub('\.bang$', '.html', args.input_filename)
  if not args.config_filename:
    args.config_filename = re.sub('\.bang$', '.bt', args.input_filename)

  args.job_name = re.sub('\.bang$', '', args.input_filename)

  # Read the configuration.
  config = yaml.load(open(args.config_filename, 'r'))
  check_config(config)

  # Read the input, expand any templates in contains, and write the output.
  in_text = open(args.input_filename, 'r').read()
  out_text = bang(config, in_text)
  open(args.output_filename, 'w').write(out_text)

def go():
  # Sort out the command line.
  parser = argparse.ArgumentParser()
  parser.add_argument(dest='input_filename', help='input filename')
  parser.add_argument('--config', '-c', dest='config_filename', help='configuration filename', default=None)
  parser.add_argument('--debug', '-d', dest='debug', help='show debugging information', action='store_true')
  parser.add_argument('--output', '-o', dest='output_filename', help='output filename', default=None)
  args = parser.parse_args()

  # We only want stack traces in debug mode.
  if args.debug:
    main(args)
  else:
    try:
      main(args)
    except Exception as e:
      print >>sys.stderr, "bang:", e
      sys.exit(1) 





if __name__ == '__main__':
  go()


